[
  {
    "doc_id": "doc_1",
    "original_uuid": "5e4c01057a10732d34784af2a97bee9d173863f043b9901de8ef7f57bc590145",
    "content": "//! Executor for differential fuzzing.\n//! It wraps two executors that will be run after each other with the same input.\n//! In comparison to the [`crate::executors::CombinedExecutor`] it also runs the secondary executor in `run_target`.\n//!\nuse core::{cell::UnsafeCell, fmt::Debug, ptr};\n\nuse libafl_bolts::{ownedref::OwnedMutPtr, tuples::MatchName};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    executors::{Executor, ExitKind, HasObservers},\n    inputs::UsesInput,\n    observers::{DifferentialObserversTuple, ObserversTuple, UsesObservers},\n    state::UsesState,\n    Error,\n};\n\n/// A [`DiffExecutor`] wraps a primary executor, forwarding its methods, and a secondary one\n#[derive(Debug)]\npub struct DiffExecutor<A, B, OTA, OTB, DOT> {\n    primary: A,\n    secondary: B,\n    observers: UnsafeCell<ProxyObserversTuple<OTA, OTB, DOT>>,\n}\n\nimpl<A, B, OTA, OTB, DOT> DiffExecutor<A, B, OTA, OTB, DOT> {\n    /// Create a new `DiffExecutor`, wrapping the given `executor`s.\n    pub fn new(primary: A, secondary: B, observers: DOT) -> Self\n    where\n        A: UsesState + HasObservers<Observers = OTA>,\n        B: UsesState<State = A::State> + HasObservers<Observers = OTB>,\n        DOT: DifferentialObserversTuple<OTA, OTB, A::State>,\n        OTA: ObserversTuple<A::State>,\n        OTB: ObserversTuple<A::State>,\n    {\n        Self {\n            primary,\n            secondary,\n            observers: UnsafeCell::new(ProxyObserversTuple {\n                primary: OwnedMutPtr::Ptr(ptr::null_mut()),\n                secondary: OwnedMutPtr::Ptr(ptr::null_mut()),\n                differential: observers,\n            }),\n        }\n    }\n\n    /// Retrieve the primary `Executor` that is wrapped by this `DiffExecutor`.\n    pub fn primary(&mut self) -> &mut A {\n        &mut self.primary\n    }\n\n    /// Retrieve the secondary `Executor` that is wrapped by this `DiffExecutor`.\n    pub fn secondary(&mut self) -> &mut B {\n        &mut self.secondary\n    }\n}\n\nimpl<A, B, EM, DOT, Z> Executor<EM, Z> for DiffExecutor<A, B, A::Observers, B::Observers, DOT>\nwhere\n    A: Executor<EM, Z> + HasObservers,\n    B: Executor<EM, Z, State = A::State> + HasObservers,\n    EM: UsesState<State = A::State>,\n    DOT: DifferentialObserversTuple<A::Observers, B::Observers, A::State>,\n    Z: UsesState<State = A::State>,\n{\n    fn run_target(\n        &mut self,\n        fuzzer: &mut Z,\n        state: &mut Self::State,\n        mgr: &mut EM,\n        input: &Self::Input,\n    ) -> Result<ExitKind, Error> {\n        self.observers(); // update in advance\n        let observers = self.observers.get_mut();\n        observers\n            .differential\n            .pre_observe_first_all(observers.primary.as_mut())?;\n        observers.primary.as_mut().pre_exec_all(state, input)?;\n        let ret1 = self.primary.run_target(fuzzer, state, mgr, input)?;\n        observers\n            .primary\n            .as_mut()\n            .post_exec_all(state, input, &ret1)?;\n        observers\n            .differential\n            .post_observe_first_all(observers.primary.as_mut())?;\n        observers\n            .differential\n            .pre_observe_second_all(observers.secondary.as_mut())?;\n        observers.secondary.as_mut().pre_exec_all(state, input)?;\n        let ret2 = self.secondary.run_target(fuzzer, state, mgr, input)?;\n        observers\n            .secondary\n            .as_mut()\n            .post_exec_all(state, input, &ret2)?;\n        observers\n            .differential\n            .post_observe_second_all(observers.secondary.as_mut())?;\n        if ret1 == ret2 {\n            Ok(ret1)\n        } else {\n            // We found a diff in the exit codes!\n            Ok(ExitKind::Diff {\n                primary: ret1.into(),\n                secondary: ret2.into(),\n            })\n        }\n    }\n}\n\n/// Proxy the observers of the inner executors\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(\n    bound = \"A: serde::Serialize + serde::de::DeserializeOwned, B: serde::Serialize + serde::de::DeserializeOwned, DOT: serde::Serialize + serde::de::DeserializeOwned\"\n)]\npub struct ProxyObserversTuple<A, B, DOT> {\n    primary: OwnedMutPtr<A>,\n    secondary: OwnedMutPtr<B>,\n    differential: DOT,\n}\n\nimpl<A, B, DOT, S> ObserversTuple<S> for ProxyObserversTuple<A, B, DOT>\nwhere\n    A: ObserversTuple<S>,\n    B: ObserversTuple<S>,\n    DOT: DifferentialObserversTuple<A, B, S>,\n    S: UsesInput,\n{\n    fn pre_exec_all(&mut self, state: &mut S, input: &S::Input) -> Result<(), Error> {\n        self.differential.pre_exec_all(state, input)\n    }\n\n    fn post_exec_all(\n        &mut self,\n        state: &mut S,\n        input: &S::Input,\n        exit_kind: &ExitKind,\n    ) -> Result<(), Error> {\n        self.differential.post_exec_all(state, input, exit_kind)\n    }\n\n    fn pre_exec_child_all(&mut self, state: &mut S, input: &S::Input) -> Result<(), Error> {\n        self.differential.pre_exec_child_all(state, input)\n    }\n\n    fn post_exec_child_all(\n        &mut self,\n        state: &mut S,\n        input: &S::Input,\n        exit_kind: &ExitKind,\n    ) -> Result<(), Error> {\n        self.differential\n            .post_exec_child_all(state, input, exit_kind)\n    }\n\n    /// Returns true if a `stdout` observer was added to the list\n    #[inline]\n    fn observes_stdout(&self) -> bool {\n        self.primary.as_ref().observes_stdout() || self.secondary.as_ref().observes_stdout()\n    }\n    /// Returns true if a `stderr` observer was added to the list\n    #[inline]\n    fn observes_stderr(&self) -> bool {\n        self.primary.as_ref().observes_stderr() || self.secondary.as_ref().observes_stderr()\n    }\n\n    /// Runs `observe_stdout` for all stdout observers in the list\n    fn observe_stdout(&mut self, stdout: &[u8]) {\n        self.primary.as_mut().observe_stderr(stdout);\n        self.secondary.as_mut().observe_stderr(stdout);\n    }\n\n    /// Runs `observe_stderr` for all stderr observers in the list\n    fn observe_stderr(&mut self, stderr: &[u8]) {\n        self.primary.as_mut().observe_stderr(stderr);\n        self.secondary.as_mut().observe_stderr(stderr);\n    }\n}\n\nimpl<A, B, DOT> MatchName for ProxyObserversTuple<A, B, DOT>\nwhere\n    A: MatchName,\n    B: MatchName,\n    DOT: MatchName,\n{\n    fn match_name<T>(&self, name: &str) -> Option<&T> {\n        if let Some(t) = self.primary.as_ref().match_name::<T>(name) {\n            Some(t)\n        } else if let Some(t) = self.secondary.as_ref().match_name::<T>(name) {\n            Some(t)\n        } else {\n            self.differential.match_name::<T>(name)\n        }\n    }\n    fn match_name_mut<T>(&mut self, name: &str) -> Option<&mut T> {\n        if let Some(t) = self.primary.as_mut().match_name_mut::<T>(name) {\n            Some(t)\n        } else if let Some(t) = self.secondary.as_mut().match_name_mut::<T>(name) {\n            Some(t)\n        } else {\n            self.differential.match_name_mut::<T>(name)\n        }\n    }\n}\n\nimpl<A, B, DOT> ProxyObserversTuple<A, B, DOT> {\n    fn set(&mut self, primary: &A, secondary: &B) {\n        self.primary = OwnedMutPtr::Ptr(ptr::from_ref(primary) as *mut A);\n        self.secondary = OwnedMutPtr::Ptr(ptr::from_ref(secondary) as *mut B);\n    }\n}\n\nimpl<A, B, OTA, OTB, DOT> UsesObservers for DiffExecutor<A, B, OTA, OTB, DOT>\nwhere\n    A: HasObservers<Observers = OTA>,\n    B: HasObservers<Observers = OTB, State = A::State>,\n    OTA: ObserversTuple<A::State>,\n    OTB: ObserversTuple<A::State>,\n    DOT: DifferentialObserversTuple<OTA, OTB, A::State>,\n{\n    type Observers = ProxyObserversTuple<OTA, OTB, DOT>;\n}\n\nimpl<A, B, OTA, OTB, DOT> UsesState for DiffExecutor<A, B, OTA, OTB, DOT>\nwhere\n    A: UsesState,\n    B: UsesState<State = A::State>,\n{\n    type State = A::State;\n}\n\nimpl<A, B, OTA, OTB, DOT> HasObservers for DiffExecutor<A, B, OTA, OTB, DOT>\nwhere\n    A: HasObservers<Observers = OTA>,\n    B: HasObservers<Observers = OTB, State = A::State>,\n    OTA: ObserversTuple<A::State>,\n    OTB: ObserversTuple<A::State>,\n    DOT: DifferentialObserversTuple<OTA, OTB, A::State>,\n{\n    #[inline]\n    fn observers(&self) -> &ProxyObserversTuple<OTA, OTB, DOT> {\n        unsafe {\n            self.observers\n                .get()\n                .as_mut()\n                .unwrap()\n                .set(self.primary.observers(), self.secondary.observers());\n            self.observers.get().as_ref().unwrap()\n        }\n    }\n\n    #[inline]\n    fn observers_mut(&mut self) -> &mut ProxyObserversTuple<OTA, OTB, DOT> {\n        unsafe {\n            self.observers\n                .get()\n                .as_mut()\n                .unwrap()\n                .set(self.primary.observers(), self.secondary.observers());\n            self.observers.get().as_mut().unwrap()\n        }\n    }\n}\n",
    "chunks": [
      {
        "chunk_id": "doc_1_chunk_0",
        "original_index": 0,
        "content": "//! Executor for differential fuzzing.\n//! It wraps two executors that will be run after each other with the same input.\n//! In comparison to the [`crate::executors::CombinedExecutor`] it also runs the secondary executor in `run_target`.\n//!\nuse core::{cell::UnsafeCell, fmt::Debug, ptr};\n\nuse libafl_bolts::{ownedref::OwnedMutPtr, tuples::MatchName};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    executors::{Executor, ExitKind, HasObservers},\n    inputs::UsesInput,\n    observers::{DifferentialObserversTuple, ObserversTuple, UsesObservers},\n    state::UsesState,\n    Error,\n};\n\n/// A [`DiffExecutor`] wraps a primary executor, forwarding its methods, and a secondary one\n#[derive(Debug)]\npub struct DiffExecutor<A, B, OTA, OTB, DOT> {\n    primary: A,\n    secondary: B,\n    observers: UnsafeCell<ProxyObserversTuple<OTA, OTB, DOT>>,\n}\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_1",
        "original_index": 1,
        "content": "impl<A, B, OTA, OTB, DOT> DiffExecutor<A, B, OTA, OTB, DOT> {\n    /// Create a new `DiffExecutor`, wrapping the given `executor`s.\n    pub fn new(primary: A, secondary: B, observers: DOT) -> Self\n    where\n        A: UsesState + HasObservers<Observers = OTA>,\n        B: UsesState<State = A::State> + HasObservers<Observers = OTB>,\n        DOT: DifferentialObserversTuple<OTA, OTB, A::State>,\n        OTA: ObserversTuple<A::State>,\n        OTB: ObserversTuple<A::State>,\n    {\n        Self {\n            primary,\n            secondary,\n            observers: UnsafeCell::new(ProxyObserversTuple {\n                primary: OwnedMutPtr::Ptr(ptr::null_mut()),\n                secondary: OwnedMutPtr::Ptr(ptr::null_mut()),\n                differential: observers,\n            }),\n        }\n    }\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_2",
        "original_index": 2,
        "content": "    /// Retrieve the primary `Executor` that is wrapped by this `DiffExecutor`.\n    pub fn primary(&mut self) -> &mut A {\n        &mut self.primary\n    }\n\n    /// Retrieve the secondary `Executor` that is wrapped by this `DiffExecutor`.\n    pub fn secondary(&mut self) -> &mut B {\n        &mut self.secondary\n    }\n}\n\nimpl<A, B, EM, DOT, Z> Executor<EM, Z> for DiffExecutor<A, B, A::Observers, B::Observers, DOT>\nwhere\n    A: Executor<EM, Z> + HasObservers,\n    B: Executor<EM, Z, State = A::State> + HasObservers,\n    EM: UsesState<State = A::State>,\n    DOT: DifferentialObserversTuple<A::Observers, B::Observers, A::State>,\n    Z: UsesState<State = A::State>,\n{\n    fn run_target(\n        &mut self,\n        fuzzer: &mut Z,\n        state: &mut Self::State,\n        mgr: &mut EM,\n        input: &Self::Input,\n    ) -> Result<ExitKind, Error> {\n        self.observers(); // update in advance\n        let observers = self.observers.get_mut();\n        observers\n            .differential\n"
      },
      {
        "chunk_id": "doc_1_chunk_3",
        "original_index": 3,
        "content": "            .pre_observe_first_all(observers.primary.as_mut())?;\n        observers.primary.as_mut().pre_exec_all(state, input)?;\n        let ret1 = self.primary.run_target(fuzzer, state, mgr, input)?;\n        observers\n            .primary\n            .as_mut()\n            .post_exec_all(state, input, &ret1)?;\n        observers\n            .differential\n            .post_observe_first_all(observers.primary.as_mut())?;\n        observers\n            .differential\n"
      },
      {
        "chunk_id": "doc_1_chunk_4",
        "original_index": 4,
        "content": "            .pre_observe_second_all(observers.secondary.as_mut())?;\n        observers.secondary.as_mut().pre_exec_all(state, input)?;\n        let ret2 = self.secondary.run_target(fuzzer, state, mgr, input)?;\n        observers\n            .secondary\n            .as_mut()\n            .post_exec_all(state, input, &ret2)?;\n        observers\n            .differential\n            .post_observe_second_all(observers.secondary.as_mut())?;\n        if ret1 == ret2 {\n            Ok(ret1)\n        } else {\n            // We found a diff in the exit codes!\n            Ok(ExitKind::Diff {\n                primary: ret1.into(),\n                secondary: ret2.into(),\n            })\n        }\n    }\n}\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_5",
        "original_index": 5,
        "content": "/// Proxy the observers of the inner executors\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(\n    bound = \"A: serde::Serialize + serde::de::DeserializeOwned, B: serde::Serialize + serde::de::DeserializeOwned, DOT: serde::Serialize + serde::de::DeserializeOwned\"\n)]\npub struct ProxyObserversTuple<A, B, DOT> {\n    primary: OwnedMutPtr<A>,\n    secondary: OwnedMutPtr<B>,\n    differential: DOT,\n}\n\nimpl<A, B, DOT, S> ObserversTuple<S> for ProxyObserversTuple<A, B, DOT>\nwhere\n    A: ObserversTuple<S>,\n    B: ObserversTuple<S>,\n    DOT: DifferentialObserversTuple<A, B, S>,\n    S: UsesInput,\n{\n    fn pre_exec_all(&mut self, state: &mut S, input: &S::Input) -> Result<(), Error> {\n        self.differential.pre_exec_all(state, input)\n    }\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_6",
        "original_index": 6,
        "content": "    fn post_exec_all(\n        &mut self,\n        state: &mut S,\n        input: &S::Input,\n        exit_kind: &ExitKind,\n    ) -> Result<(), Error> {\n        self.differential.post_exec_all(state, input, exit_kind)\n    }\n\n    fn pre_exec_child_all(&mut self, state: &mut S, input: &S::Input) -> Result<(), Error> {\n        self.differential.pre_exec_child_all(state, input)\n    }\n\n    fn post_exec_child_all(\n        &mut self,\n        state: &mut S,\n        input: &S::Input,\n        exit_kind: &ExitKind,\n    ) -> Result<(), Error> {\n        self.differential\n            .post_exec_child_all(state, input, exit_kind)\n    }\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_7",
        "original_index": 7,
        "content": "    /// Returns true if a `stdout` observer was added to the list\n    #[inline]\n    fn observes_stdout(&self) -> bool {\n        self.primary.as_ref().observes_stdout() || self.secondary.as_ref().observes_stdout()\n    }\n    /// Returns true if a `stderr` observer was added to the list\n    #[inline]\n    fn observes_stderr(&self) -> bool {\n        self.primary.as_ref().observes_stderr() || self.secondary.as_ref().observes_stderr()\n    }\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_8",
        "original_index": 8,
        "content": "    /// Runs `observe_stdout` for all stdout observers in the list\n    fn observe_stdout(&mut self, stdout: &[u8]) {\n        self.primary.as_mut().observe_stderr(stdout);\n        self.secondary.as_mut().observe_stderr(stdout);\n    }\n\n    /// Runs `observe_stderr` for all stderr observers in the list\n    fn observe_stderr(&mut self, stderr: &[u8]) {\n        self.primary.as_mut().observe_stderr(stderr);\n        self.secondary.as_mut().observe_stderr(stderr);\n    }\n}\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_9",
        "original_index": 9,
        "content": "impl<A, B, DOT> MatchName for ProxyObserversTuple<A, B, DOT>\nwhere\n    A: MatchName,\n    B: MatchName,\n    DOT: MatchName,\n{\n    fn match_name<T>(&self, name: &str) -> Option<&T> {\n        if let Some(t) = self.primary.as_ref().match_name::<T>(name) {\n            Some(t)\n        } else if let Some(t) = self.secondary.as_ref().match_name::<T>(name) {\n            Some(t)\n        } else {\n            self.differential.match_name::<T>(name)\n        }\n    }\n    fn match_name_mut<T>(&mut self, name: &str) -> Option<&mut T> {\n        if let Some(t) = self.primary.as_mut().match_name_mut::<T>(name) {\n            Some(t)\n        } else if let Some(t) = self.secondary.as_mut().match_name_mut::<T>(name) {\n            Some(t)\n        } else {\n            self.differential.match_name_mut::<T>(name)\n        }\n    }\n}\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_10",
        "original_index": 10,
        "content": "impl<A, B, DOT> ProxyObserversTuple<A, B, DOT> {\n    fn set(&mut self, primary: &A, secondary: &B) {\n        self.primary = OwnedMutPtr::Ptr(ptr::from_ref(primary) as *mut A);\n        self.secondary = OwnedMutPtr::Ptr(ptr::from_ref(secondary) as *mut B);\n    }\n}\n\nimpl<A, B, OTA, OTB, DOT> UsesObservers for DiffExecutor<A, B, OTA, OTB, DOT>\nwhere\n    A: HasObservers<Observers = OTA>,\n    B: HasObservers<Observers = OTB, State = A::State>,\n    OTA: ObserversTuple<A::State>,\n    OTB: ObserversTuple<A::State>,\n    DOT: DifferentialObserversTuple<OTA, OTB, A::State>,\n{\n    type Observers = ProxyObserversTuple<OTA, OTB, DOT>;\n}\n\nimpl<A, B, OTA, OTB, DOT> UsesState for DiffExecutor<A, B, OTA, OTB, DOT>\nwhere\n    A: UsesState,\n    B: UsesState<State = A::State>,\n{\n    type State = A::State;\n}\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_11",
        "original_index": 11,
        "content": "impl<A, B, OTA, OTB, DOT> HasObservers for DiffExecutor<A, B, OTA, OTB, DOT>\nwhere\n    A: HasObservers<Observers = OTA>,\n    B: HasObservers<Observers = OTB, State = A::State>,\n    OTA: ObserversTuple<A::State>,\n    OTB: ObserversTuple<A::State>,\n    DOT: DifferentialObserversTuple<OTA, OTB, A::State>,\n{\n    #[inline]\n    fn observers(&self) -> &ProxyObserversTuple<OTA, OTB, DOT> {\n        unsafe {\n            self.observers\n                .get()\n                .as_mut()\n                .unwrap()\n                .set(self.primary.observers(), self.secondary.observers());\n            self.observers.get().as_ref().unwrap()\n        }\n    }\n\n"
      },
      {
        "chunk_id": "doc_1_chunk_12",
        "original_index": 12,
        "content": "    #[inline]\n    fn observers_mut(&mut self) -> &mut ProxyObserversTuple<OTA, OTB, DOT> {\n        unsafe {\n            self.observers\n                .get()\n                .as_mut()\n                .unwrap()\n                .set(self.primary.observers(), self.secondary.observers());\n            self.observers.get().as_mut().unwrap()\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "doc_id": "doc_2",
    "original_uuid": "78cd6ead8e87695b47c2904e3027ae2b7251677caa5c5815b38c8756fe1a0b0c",
    "content": "#[cfg(windows)]\nuse std::ptr::write_volatile;\nuse std::{path::PathBuf, ptr::write};\n\n#[cfg(feature = \"tui\")]\nuse libafl::monitors::tui::{ui::TuiUI, TuiMonitor};\n#[cfg(not(feature = \"tui\"))]\nuse libafl::monitors::SimpleMonitor;\nuse libafl::{\n    corpus::{InMemoryCorpus, OnDiskCorpus},\n    events::SimpleEventManager,\n    executors::{inprocess::InProcessExecutor, ExitKind},\n    feedbacks::{CrashFeedback, MaxMapFeedback},\n    fuzzer::{Fuzzer, StdFuzzer},\n    inputs::{BytesInput, HasTargetBytes},\n    mutators::{StdScheduledMutator, StringCategoryRandMutator, StringSubcategoryRandMutator},\n    observers::StdMapObserver,\n    schedulers::QueueScheduler,\n    stages::{mutational::StdMutationalStage, StringIdentificationStage},\n    state::StdState,\n    Evaluator,\n};\nuse libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};\n\n/// Coverage map with explicit assignments due to the lack of instrumentation\nstatic mut SIGNALS: [u8; 64] = [0; 64];\nstatic mut SIGNALS_PTR: *mut u8 = unsafe { SIGNALS.as_mut_ptr() };\n\n/// Assign a signal to the signals map\nfn signals_set(idx: usize) {\n    unsafe { write(SIGNALS_PTR.add(idx), 1) };\n}\n\n#[allow(clippy::similar_names, clippy::manual_assert)]\npub fn main() {\n    // The closure that we want to fuzz\n    let mut harness = |input: &BytesInput| {\n        let target = input.target_bytes();\n        let buf = target.as_slice();\n        let goal = b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n        let mut i = 0;\n        for _ in buf.iter().zip(goal).take_while(|(b, c)| b == c) {\n            signals_set(i);\n            i += 1;\n        }\n        if i == goal.len() {\n            #[cfg(unix)]\n            panic!(\"Artificial bug triggered =)\");\n\n            #[cfg(windows)]\n            unsafe {\n                write_volatile(0 as *mut u32, 0);\n            }\n        }\n        ExitKind::Ok\n    };\n\n    // Create an observation channel using the signals map\n    let observer = unsafe { StdMapObserver::from_mut_ptr(\"signals\", SIGNALS_PTR, SIGNALS.len()) };\n\n    // Feedback to rate the interestingness of an input\n    let mut feedback = MaxMapFeedback::new(&observer);\n\n    // A feedback to choose if an input is a solution or not\n    let mut objective = CrashFeedback::new();\n\n    // create a State from scratch\n    let mut state = StdState::new(\n        // RNG\n        StdRand::with_seed(current_nanos()),\n        // Corpus that will be evolved, we keep it in memory for performance\n        InMemoryCorpus::new(),\n        // Corpus in which we store solutions (crashes in this example),\n        // on disk so the user can get them after stopping the fuzzer\n        OnDiskCorpus::new(PathBuf::from(\"./crashes\")).unwrap(),\n        // States of the feedbacks.\n        // The feedbacks can report the data that should persist in the State.\n        &mut feedback,\n        // Same for objective feedbacks\n        &mut objective,\n    )\n    .unwrap();\n\n    // The Monitor trait define how the fuzzer stats are displayed to the user\n    #[cfg(not(feature = \"tui\"))]\n    let mon = SimpleMonitor::new(|s| println!(\"{s}\"));\n    #[cfg(feature = \"tui\")]\n    let ui = TuiUI::with_version(String::from(\"Baby Fuzzer\"), String::from(\"0.0.1\"), false);\n    #[cfg(feature = \"tui\")]\n    let mon = TuiMonitor::new(ui);\n\n    // The event manager handle the various events generated during the fuzzing loop\n    // such as the notification of the addition of a new item to the corpus\n    let mut mgr = SimpleEventManager::new(mon);\n\n    // A queue policy to get testcasess from the corpus\n    let scheduler = QueueScheduler::new();\n\n    // A fuzzer with feedbacks and a corpus scheduler\n    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);\n\n    // Create the executor for an in-process function with just one observer\n    let mut executor = InProcessExecutor::new(\n        &mut harness,\n        tuple_list!(observer),\n        &mut fuzzer,\n        &mut state,\n        &mut mgr,\n    )\n    .expect(\"Failed to create the Executor\");\n\n    // Generate 8 initial inputs\n    fuzzer\n        .evaluate_input(\n            &mut state,\n            &mut executor,\n            &mut mgr,\n            BytesInput::new(vec![b'a']),\n        )\n        .unwrap();\n\n    // Setup a mutational stage with a basic bytes mutator\n    let mutator = StdScheduledMutator::new(tuple_list!(\n        StringCategoryRandMutator,\n        StringSubcategoryRandMutator,\n        StringSubcategoryRandMutator,\n        StringSubcategoryRandMutator,\n        StringSubcategoryRandMutator\n    ));\n    let mut stages = tuple_list!(\n        StringIdentificationStage::new(),\n        StdMutationalStage::transforming(mutator)\n    );\n\n    fuzzer\n        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)\n        .expect(\"Error in the fuzzing loop\");\n}\n",
    "chunks": [
      {
        "chunk_id": "doc_2_chunk_0",
        "original_index": 0,
        "content": "#[cfg(windows)]\nuse std::ptr::write_volatile;\nuse std::{path::PathBuf, ptr::write};\n\n#[cfg(feature = \"tui\")]\nuse libafl::monitors::tui::{ui::TuiUI, TuiMonitor};\n#[cfg(not(feature = \"tui\"))]\nuse libafl::monitors::SimpleMonitor;\nuse libafl::{\n    corpus::{InMemoryCorpus, OnDiskCorpus},\n    events::SimpleEventManager,\n    executors::{inprocess::InProcessExecutor, ExitKind},\n    feedbacks::{CrashFeedback, MaxMapFeedback},\n    fuzzer::{Fuzzer, StdFuzzer},\n    inputs::{BytesInput, HasTargetBytes},\n    mutators::{StdScheduledMutator, StringCategoryRandMutator, StringSubcategoryRandMutator},\n    observers::StdMapObserver,\n    schedulers::QueueScheduler,\n    stages::{mutational::StdMutationalStage, StringIdentificationStage},\n    state::StdState,\n    Evaluator,\n};\nuse libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};\n\n"
      },
      {
        "chunk_id": "doc_2_chunk_1",
        "original_index": 1,
        "content": "/// Coverage map with explicit assignments due to the lack of instrumentation\nstatic mut SIGNALS: [u8; 64] = [0; 64];\nstatic mut SIGNALS_PTR: *mut u8 = unsafe { SIGNALS.as_mut_ptr() };\n\n/// Assign a signal to the signals map\nfn signals_set(idx: usize) {\n    unsafe { write(SIGNALS_PTR.add(idx), 1) };\n}\n\n#[allow(clippy::similar_names, clippy::manual_assert)]\npub fn main() {\n    // The closure that we want to fuzz\n    let mut harness = |input: &BytesInput| {\n        let target = input.target_bytes();\n        let buf = target.as_slice();\n        let goal = b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n        let mut i = 0;\n        for _ in buf.iter().zip(goal).take_while(|(b, c)| b == c) {\n            signals_set(i);\n            i += 1;\n        }\n        if i == goal.len() {\n            #[cfg(unix)]\n            panic!(\"Artificial bug triggered =)\");\n\n"
      },
      {
        "chunk_id": "doc_2_chunk_2",
        "original_index": 2,
        "content": "            #[cfg(windows)]\n            unsafe {\n                write_volatile(0 as *mut u32, 0);\n            }\n        }\n        ExitKind::Ok\n    };\n\n    // Create an observation channel using the signals map\n    let observer = unsafe { StdMapObserver::from_mut_ptr(\"signals\", SIGNALS_PTR, SIGNALS.len()) };\n\n    // Feedback to rate the interestingness of an input\n    let mut feedback = MaxMapFeedback::new(&observer);\n\n    // A feedback to choose if an input is a solution or not\n    let mut objective = CrashFeedback::new();\n\n"
      },
      {
        "chunk_id": "doc_2_chunk_3",
        "original_index": 3,
        "content": "    // create a State from scratch\n    let mut state = StdState::new(\n        // RNG\n        StdRand::with_seed(current_nanos()),\n        // Corpus that will be evolved, we keep it in memory for performance\n        InMemoryCorpus::new(),\n        // Corpus in which we store solutions (crashes in this example),\n        // on disk so the user can get them after stopping the fuzzer\n        OnDiskCorpus::new(PathBuf::from(\"./crashes\")).unwrap(),\n        // States of the feedbacks.\n        // The feedbacks can report the data that should persist in the State.\n        &mut feedback,\n        // Same for objective feedbacks\n        &mut objective,\n    )\n    .unwrap();\n\n"
      },
      {
        "chunk_id": "doc_2_chunk_4",
        "original_index": 4,
        "content": "    // The Monitor trait define how the fuzzer stats are displayed to the user\n    #[cfg(not(feature = \"tui\"))]\n    let mon = SimpleMonitor::new(|s| println!(\"{s}\"));\n    #[cfg(feature = \"tui\")]\n    let ui = TuiUI::with_version(String::from(\"Baby Fuzzer\"), String::from(\"0.0.1\"), false);\n    #[cfg(feature = \"tui\")]\n    let mon = TuiMonitor::new(ui);\n\n    // The event manager handle the various events generated during the fuzzing loop\n    // such as the notification of the addition of a new item to the corpus\n    let mut mgr = SimpleEventManager::new(mon);\n\n    // A queue policy to get testcasess from the corpus\n    let scheduler = QueueScheduler::new();\n\n    // A fuzzer with feedbacks and a corpus scheduler\n    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);\n\n"
      },
      {
        "chunk_id": "doc_2_chunk_5",
        "original_index": 5,
        "content": "    // Create the executor for an in-process function with just one observer\n    let mut executor = InProcessExecutor::new(\n        &mut harness,\n        tuple_list!(observer),\n        &mut fuzzer,\n        &mut state,\n        &mut mgr,\n    )\n    .expect(\"Failed to create the Executor\");\n\n    // Generate 8 initial inputs\n    fuzzer\n        .evaluate_input(\n            &mut state,\n            &mut executor,\n            &mut mgr,\n            BytesInput::new(vec![b'a']),\n        )\n        .unwrap();\n\n"
      },
      {
        "chunk_id": "doc_2_chunk_6",
        "original_index": 6,
        "content": "    // Setup a mutational stage with a basic bytes mutator\n    let mutator = StdScheduledMutator::new(tuple_list!(\n        StringCategoryRandMutator,\n        StringSubcategoryRandMutator,\n        StringSubcategoryRandMutator,\n        StringSubcategoryRandMutator,\n        StringSubcategoryRandMutator\n    ));\n    let mut stages = tuple_list!(\n        StringIdentificationStage::new(),\n        StdMutationalStage::transforming(mutator)\n    );\n\n    fuzzer\n        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)\n        .expect(\"Error in the fuzzing loop\");\n}\n"
      }
    ]
  }
]